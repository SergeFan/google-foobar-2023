use std::collections::HashMap;

pub fn count_previous_status(current_status: Vec<Vec<bool>>) -> usize {
    let column_height = current_status.len();
    let row_width = current_status[0].len();

    // Previous status column height equals current status column height plus 1,
    // thus shift 2 (i.e. `10`) with current status height
    let previous_status_column_varieties: usize = 2 << column_height;

    // HashMap to get previous status column pairs by current status column
    let mut previous_status_column_pairs: HashMap<usize, Vec<(usize, usize)>> = HashMap::new();

    // Calculate all possible status columns generated by all possible previous status column pairs,
    // then make all results recorded
    for first_column in 0..previous_status_column_varieties {
        for second_column in 0..previous_status_column_varieties {
            let generated_column =
                generate_status_column(first_column, second_column, column_height);

            match previous_status_column_pairs.get_mut(&generated_column) {
                None => {
                    previous_status_column_pairs
                        .insert(generated_column, vec![(first_column, second_column)]);
                }
                Some(previous_status_column_pairs) => {
                    previous_status_column_pairs.push((first_column, second_column));
                }
            }
        }
    }

    let mut column_values: Vec<usize> = Vec::new();

    // Treat status column bool values as bits, thus whole column can be stored as integer
    for i in 0..row_width {
        let mut column_value: usize = 0;

        for j in 0..column_height {
            if current_status[j][i] {
                column_value |= 1 << j;
            }
        }

        column_values.push(column_value);
    }

    let mut column_variety_count = vec![1; previous_status_column_varieties];

    // For each current status column, find possible previous status column pairs and add-up all possible varieties
    for column_value in column_values {
        let mut column_pair_variety_count = vec![0; previous_status_column_varieties];

        if let Some(previous_status_column_pairs) = previous_status_column_pairs.get(&column_value)
        {
            for (first_column, second_column) in previous_status_column_pairs {
                column_pair_variety_count[*second_column] += column_variety_count[*first_column];
            }

            column_variety_count = column_pair_variety_count;
        }
    }

    column_variety_count.iter().sum()
}

fn generate_status_column(
    first_column: usize,
    second_column: usize,
    column_height: usize,
) -> usize {
    /*!
    - parameters
        `first_column`: previous status column pair - left column
        `second_column`: previous status column pair - right column
        `column_height`: current status column height

    - explanation
        To generate current status column, a `2 * (column_height + 1)` sized previous status column pair is needed.

        `column_a/c` represent the slices of `first_column[0..column_height]` and `first_column[1..column_height + 1]` (as integers respectively).
        `column_b/d` represent the slices of `second_column[0..column_height]` and `second_column[1..column_height + 1]` (as integers respectively).

        These four columns have the same height of `current_height`,
        and the elements with the same index of each column are exactly the elements of `2 x 2` grids of the previous status column pair.

        Since the restriction that only one grid of `2 x 2` grids is `true` will generate current status grid as `true`,
        thus the BIT_AND of 1 and 3 NOTs can generate the current status grid (i.e. 1 `true` and 3 `false` will result in `true`, others will result in `false`)

        For the four BIT_ANDs, take BIT_OR for the final result,
        which represents that the current status grid can be generated from varies `2 x 2` previous status grids,
        therefore previous status column pair varieties that generate the same current status column can be grouped.
    */

    let column_a = first_column & !(1 << column_height);
    let column_b = second_column & !(1 << column_height);
    let column_c = first_column >> 1;
    let column_d = second_column >> 1;

    (column_a & !column_b & !column_c & !column_d)
        | (!column_a & column_b & !column_c & !column_d)
        | (!column_a & !column_b & column_c & !column_d)
        | (!column_a & !column_b & !column_c & column_d)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_count_previous_status() {
        assert_eq!(
            count_previous_status(vec![
                vec![true, true, false, true, false, true, false, true, true, false],
                vec![true, true, false, false, false, false, true, true, true, false],
                vec![true, true, false, false, false, false, false, false, false, true],
                vec![false, true, false, false, false, false, true, true, false, false],
            ]),
            11567
        );

        assert_eq!(
            count_previous_status(vec![
                vec![true, false, true],
                vec![false, true, false],
                vec![true, false, true],
            ]),
            4
        );

        assert_eq!(
            count_previous_status(vec![
                vec![true, false, true, false, false, true, true, true],
                vec![true, false, true, false, false, false, true, false],
                vec![true, true, true, false, false, false, true, false],
                vec![true, false, true, false, false, false, true, false],
                vec![true, false, true, false, false, true, true, true],
            ]),
            254
        );
    }
}
