use std::collections::HashMap;

pub fn count_previous_status(current_status: Vec<Vec<bool>>) -> usize {
    let column_height = current_status.len();
    let row_width = current_status[0].len();

    // Previous status column height equals current status column height plus 1,
    // thus shift 2 (i.e. `10`) with current status height
    let previous_status_column_varieties: usize = 2 << column_height;

    // HashMap to get previous status column pairs by current status column
    let mut previous_status_column_pairs: HashMap<usize, Vec<(usize, usize)>> = HashMap::new();

    // Calculate all possible status columns generated by all possible previous status column pairs,
    // then make all results recorded
    for first_column in 0..previous_status_column_varieties {
        for second_column in 0..previous_status_column_varieties {
            let generated_column =
                generate_next_status_column(first_column, second_column, column_height);

            match previous_status_column_pairs.get_mut(&generated_column) {
                None => {
                    previous_status_column_pairs
                        .insert(generated_column, vec![(first_column, second_column)]);
                }
                Some(previous_status_column_pairs) => {
                    previous_status_column_pairs.push((first_column, second_column));
                }
            }
        }
    }

    // Treat status column bool values as bits, thus whole column can be stored as integer
    let mut column_values: Vec<usize> = Vec::new();

    for i in 0..row_width {
        let mut column_value: usize = 0;

        for j in 0..column_height {
            if current_status[j][i] {
                column_value |= 1 << j;
            }
        }

        column_values.push(column_value);
    }

    let mut column_variety_count = vec![1; previous_status_column_varieties];

    for column_value in column_values {
        let mut column_pair_variety_count = vec![0; previous_status_column_varieties];

        if let Some(previous_status_column_pairs) = previous_status_column_pairs.get(&column_value)
        {
            for (first_column, second_column) in previous_status_column_pairs {
                column_pair_variety_count[*second_column] += column_variety_count[*first_column];
            }

            column_variety_count = column_pair_variety_count;
        }
    }

    column_variety_count.iter().sum()
}

fn generate_next_status_column(
    first_column: usize,
    second_column: usize,
    column_height: usize,
) -> usize {
    let column_a = first_column & !(1 << column_height);
    let column_b = second_column & !(1 << column_height);
    let column_c = first_column >> 1;
    let column_d = second_column >> 1;

    (column_a & !column_b & !column_c & !column_d)
        | (!column_a & column_b & !column_c & !column_d)
        | (!column_a & !column_b & column_c & !column_d)
        | (!column_a & !column_b & !column_c & column_d)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_count_previous_status() {
        assert_eq!(
            count_previous_status(vec![
                vec![true, true, false, true, false, true, false, true, true, false],
                vec![true, true, false, false, false, false, true, true, true, false],
                vec![true, true, false, false, false, false, false, false, false, true],
                vec![false, true, false, false, false, false, true, true, false, false],
            ]),
            11567
        );

        assert_eq!(
            count_previous_status(vec![
                vec![true, false, true],
                vec![false, true, false],
                vec![true, false, true],
            ]),
            4
        );

        assert_eq!(
            count_previous_status(vec![
                vec![true, false, true, false, false, true, true, true],
                vec![true, false, true, false, false, false, true, false],
                vec![true, true, true, false, false, false, true, false],
                vec![true, false, true, false, false, false, true, false],
                vec![true, false, true, false, false, true, true, true],
            ]),
            254
        );
    }
}
